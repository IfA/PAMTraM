/**
 *
 */
package de.mfreund.gentrans.transformation;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.ecore.EObject;

import de.mfreund.gentrans.transformation.matching.MatchedSectionDescriptor;
import pamtram.ConditionalElement;
import pamtram.DeactivatableElement;
import pamtram.mapping.InstantiableMappingHintGroup;
import pamtram.mapping.Mapping;
import pamtram.mapping.MappingHint;
import pamtram.mapping.MappingHintGroup;
import pamtram.mapping.MappingHintGroupImporter;
import pamtram.mapping.MappingHintGroupType;
import pamtram.mapping.MappingHintType;
import pamtram.metamodel.SourceSectionClass;
import pamtram.metamodel.TargetSectionClass;

/**
 * Class for storing HintValues and target section objects generated by applying
 * a Mapping.
 * <p>
 * Objects of this Class can be seen as Instances of a mapping.
 *
 * @author Sascha Steffen
 * @version 1.0
 */
public class MappingInstanceStorage {

	/**
	 * The source model Objects, referenced by containment References, that were
	 * mapped by this mapping instance.
	 */
	private LinkedHashMap<SourceSectionClass, Set<EObject>> sourceModelObjetsMapped;

	/**
	 * The associated Mapping
	 */
	private Mapping mapping;

	/**
	 * The EObject associated to the root Class of the soureceMMSection of the
	 * mapping.
	 */
	private EObject associatedSourceModelElement;

	/**
	 * The SourceSectionClass associated to the root Class of the soureceMMSection
	 * of the mapping.
	 */
	private SourceSectionClass associatedSourceClass;

	/**
	 * Generated EObjects sorted by TargetSectionCLass
	 */
	private final LinkedHashMap<InstantiableMappingHintGroup, LinkedHashMap<TargetSectionClass, LinkedList<EObjectWrapper>>> instancesBySection;

	/**
	 * This contains the hint values that shall be used when instantiating, linking, and expanding the target section(s). 
	 */
	private final HintValueStorage hintValues;
	
	/**
	 * This keeps track of those {@link ConditionalElement ConditionalElements} ({@link Mapping}, {@link MappingHintGroup}, or {@link MappingHint})
	 * for that the checking of the conditions in the {@link SourceSectionMatcher} returned '<em>false</em>' for the current
	 * {@link #associatedSourceModelElement}.
	 */
	private final Set<ConditionalElement> elementsWithNegativeConditions;

	/**
	 * This contains the still unsynced hint values that are used by the mapping hints.
	 */
	private final HintValueStorage unsyncedHintValues;
	
	/**
	 * This keeps track of the {@link MatchedSectionDescriptor} that represents the 
	 * {@link EObject#eContainer()} of the {@link #associatedSourceModelElement}.
	 * <p />
	 * This can be used to determine 'external hint values'.
	 */
	private MatchedSectionDescriptor containerDescriptor;

	/**
	 * This constructs an instance.
	 */
	public MappingInstanceStorage() {
	
		sourceModelObjetsMapped = new LinkedHashMap<>();
		mapping = null;
		associatedSourceModelElement = null;
		associatedSourceClass = null;
		instancesBySection = new LinkedHashMap<>();
		hintValues = new HintValueStorage();
		elementsWithNegativeConditions = new HashSet<>();
		unsyncedHintValues = new HintValueStorage();
	
	}

	/**
	 * This is the getter for the {@link #hintValues}.
	 * 
	 * @return The hint values that shall be used when instantiating, linking, and expanding the target section(s).
	 */
	public HintValueStorage getHintValues() {
		return this.hintValues;
	}
	
	/**
	 * This adds a new {@link ConditionalElement} to the set of {@link #elementsWithNegativeConditions}. This will result
	 * in the element to be ignored during the steps of the transformation. 
	 * 
	 * @param element The {@link ConditionalElement} to be added.
	 */
	public void addElementWithNegativeCondition(ConditionalElement element) {
		this.elementsWithNegativeConditions.add(element);
	}
	
	/**
	 * Whether the given {@link ConditionalElement} is part of the {@link #elementsWithNegativeConditions}.
	 * 
	 * @param element The {@link ConditionalElement} to be checked.
	 * @return '<em><b>true</b></em>' if the element is part of the {@link #elementsWithNegativeConditions}; '<em><b>false</b></em>' otherwise
	 */
	public boolean isElementWithNegativeCondition(ConditionalElement element) {
		return this.elementsWithNegativeConditions.contains(element);
	}

	/**
	 * This is the getter for the {@link #unsyncedHintValues}.
	 * 
	 * @return The still unsynced hint values that are used by the mapping hints.
	 */
	public HintValueStorage getUnsyncedHintValues() {
		return this.unsyncedHintValues;
	}

	/**
	 * Add mapped source model Objects and HintValues of another
	 * MappingInstanceStorage
	 *
	 * @param newRefsAndHints
	 */
	public void add(final MappingInstanceStorage newRefsAndHints) {
		// combine refs
		addSourceModelObjectsMapped(newRefsAndHints
				.getSourceModelObjectsMapped());

		// combine hints
		hintValues.addHintValues(newRefsAndHints.getHintValues());

		// combine unsynced hints
		unsyncedHintValues.addHintValues(newRefsAndHints.getUnsyncedHintValues());

	}

	/**
	 * Register several new target model instances
	 *
	 * @param grp
	 * @param section
	 * @param insts
	 */
	public void addInstances(final InstantiableMappingHintGroup grp,
			final TargetSectionClass section,
			final Collection<EObjectWrapper> insts) {
		generateInstancesCollectionsIfNeeded(grp, section);
		instancesBySection.get(grp).get(section).addAll(insts);
	}

	/**
	 * Register mapped source model object
	 *
	 * @param srcModelElement
	 * @param srcSectionClass
	 */
	public void addSourceModelObjectMapped(final EObject srcModelElement,
			final SourceSectionClass srcSectionClass) {
		if (!sourceModelObjetsMapped.containsKey(srcModelElement)) {
			sourceModelObjetsMapped.put(srcSectionClass,
					new LinkedHashSet<EObject>());
		}
		sourceModelObjetsMapped.get(srcSectionClass).add(srcModelElement);

	}

	/**
	 * Register mapped source model objects
	 *
	 * @param refs
	 */
	public void addSourceModelObjectsMapped(
			final LinkedHashMap<SourceSectionClass, Set<EObject>> refs) {
		for(final SourceSectionClass key : refs.keySet()) {
			if (!sourceModelObjetsMapped.containsKey(key)) {
				sourceModelObjetsMapped.put(key, new LinkedHashSet<EObject>());
			}
			sourceModelObjetsMapped.get(key).addAll(refs.get(key));
		}
	}

	/**
	 * Check source model object registry wether object was mapped already
	 *
	 * @param object
	 * @return true - if EObject is registered
	 */
	public boolean containsSourceModelObjectMapped(final EObject object) {
		return sourceModelObjetsMapped.values().contains(object);
	}

	/**
	 * Generate collections for grp and section in the instancesBySection Map in
	 * case they do not exist yet
	 *
	 * @param grp
	 * @param section
	 */
	private void generateInstancesCollectionsIfNeeded(
			final InstantiableMappingHintGroup grp,
			final TargetSectionClass section) {
		if (!instancesBySection.containsKey(grp)) {
			instancesBySection
			.put(grp,
					new LinkedHashMap<TargetSectionClass, LinkedList<EObjectWrapper>>());
		}

		if (!instancesBySection.get(grp).containsKey(section)) {
			instancesBySection.get(grp).put(section,
					new LinkedList<EObjectWrapper>());
		}
	}

	/**
	 * @return associated SourceSectionClass
	 */
	public SourceSectionClass getAssociatedSourceClass() {
		return associatedSourceClass;
	}

	/**
	 * @return associated source Model element
	 */
	public EObject getAssociatedSourceModelElement() {
		return associatedSourceModelElement;
	}

	/**
	 * generated target section instances associated with the MappingHintGroup
	 * and the specific section
	 *
	 * @param group
	 * @param section
	 * @return
	 */
	public LinkedList<EObjectWrapper> getInstances(
			final InstantiableMappingHintGroup group,
			final TargetSectionClass section) {
		if (instancesBySection.containsKey(group)) {
			return instancesBySection.get(group).get(section);

		} else {
			return null;
		}
	}

	/**
	 * Get generated target section instances associated with the
	 * MappingHintGroup
	 *
	 * @param group
	 * @return generated target section instances associated with the
	 *         MappingHintGroup
	 */
	public LinkedHashMap<TargetSectionClass, LinkedList<EObjectWrapper>> getInstancesBySection(
			final InstantiableMappingHintGroup group) {
		return instancesBySection.get(group);
	}

	/**
	 * @return associated Mapping
	 */
	public Mapping getMapping() {
		return mapping;
	}
	
	/**
	 * This returns the {@link DeactivatableElement#isDeactivated() active} {@link MappingHintGroupType hint groups} of the 
	 * {@link #mapping} associated with this. If the hint group is a {@link ConditionalElement} this also checks that
	 * the condition of the hint groups has not been determined as {@link #isElementWithNegativeCondition(ConditionalElement) false}.
	 * 
	 * @return The list of active and valid {@link MappingHintGroupType hint groups} for this {@link MappingInstanceStorage}.
	 */
	public List<MappingHintGroupType> getMappingHintGroups() {
		
		return this.getMapping().getActiveMappingHintGroups().parallelStream().filter(
				hg -> !(hg instanceof ConditionalElement) || !isElementWithNegativeCondition((ConditionalElement) hg)).collect(Collectors.toList());
	}
	
	/**
	 * This returns the {@link DeactivatableElement#isDeactivated() active} {@link MappingHintGroupImporter hint group importers} of the 
	 * {@link #mapping} associated with this. This also checks that the condition of the hint group importers has not been determined 
	 * as {@link #isElementWithNegativeCondition(ConditionalElement) false}.
	 * 
	 * @return The list of active and valid {@link MappingHintGroupImporter hint group importers} for this {@link MappingInstanceStorage}.
	 */
	public List<MappingHintGroupImporter> getMappingHintGroupImporters() {
		
		return this.getMapping().getActiveImportedMappingHintGroups().parallelStream().filter(
				hg -> !isElementWithNegativeCondition(hg)).collect(Collectors.toList());
	}
	
	/**
	 * This returns the hints for the given {@link MappingHintGroupType hint group} for that the condition has not been determined 
	 * as {@link #isElementWithNegativeCondition(ConditionalElement) false}.
	 * 
	 * @return The list of valid {@link MappingHint hints} for the given {@link MappingHintGroupType}.
	 */
	public List<MappingHint> getMappingHints(MappingHintGroupType hintGroup) {
		
		if(hintGroup instanceof ConditionalElement && isElementWithNegativeCondition((ConditionalElement) hintGroup)) {
			return new BasicEList<>();
		}
		
		return hintGroup.getMappingHints().parallelStream().filter(
				h -> !isElementWithNegativeCondition(h)).collect(Collectors.toList());
	}
	
	/**
	 * This returns the hints for the given {@link MappingHintGroupImporter hint group importer} for that the condition has not been determined 
	 * as {@link #isElementWithNegativeCondition(ConditionalElement) false}.
	 * 
	 * @return The list of valid {@link MappingHint hints} for the given {@link MappingHintGroupImporter}.
	 */
	public List<MappingHintType> getMappingHints(MappingHintGroupImporter hintGroupImporter) {
		
		if(isElementWithNegativeCondition((ConditionalElement) hintGroupImporter)) {
			return new BasicEList<>();
		}
		
		return hintGroupImporter.getMappingHints().parallelStream().filter(
				h -> !(h instanceof ConditionalElement) || !isElementWithNegativeCondition((ConditionalElement) h)).collect(Collectors.toList());
	}

	/**
	 * @return map of the source model Objects mapped
	 */
	public final LinkedHashMap<SourceSectionClass, Set<EObject>> getSourceModelObjectsMapped() {
		return sourceModelObjetsMapped;
	}

	/**
	 * @param associatedSourceClass
	 * @param associatedSourceModelElement
	 */
	public void setAssociatedSourceElement(
			final SourceSectionClass associatedSourceClass,
			final EObject associatedSourceModelElement) {
		this.associatedSourceModelElement = associatedSourceModelElement;
		this.associatedSourceClass = associatedSourceClass;
	}

	/**
	 * Set the associated mapping
	 *
	 * @param mapping
	 */
	public void setMapping(final Mapping mapping) {
		this.mapping = mapping;
	}

	/**
	 * Set the map of source model objects mapped
	 *
	 * @param refs
	 */
	public void setSourceModelObjectsMapped(
			final LinkedHashMap<SourceSectionClass, Set<EObject>> refs) {
		sourceModelObjetsMapped = refs;
	}

	/**
	 * This returns the {@link #containerDescriptor}.
	 * 
	 * @return The {@link MatchedSectionDescriptor} that represents the 
	 * {@link EObject#eContainer()} of the {@link #associatedSourceModelElement}.
	 */
	public MatchedSectionDescriptor getContainerDescriptor() {
		return containerDescriptor;
	}

	/**
	 * Set the {@link #containerDescriptor}.
	 * @param containerDescriptor tThe {@link MatchedSectionDescriptor} that represents the 
	 * {@link EObject#eContainer()} of the {@link #associatedSourceModelElement}.
	 */
	public void setContainerDescriptor(MatchedSectionDescriptor containerDescriptor) {
		this.containerDescriptor = containerDescriptor;
	}

}

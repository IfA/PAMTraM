/**
 * 
 */
package de.mfreund.gentrans.transformation;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;

import pamtram.mapping.ComplexAttributeMappingSourceElement;
import pamtram.mapping.ComplexAttributeMatcherSourceElement;
import pamtram.mapping.ComplexModelConnectionHintSourceElement;
import pamtram.mapping.ExpressionVariable;
import pamtram.mapping.InstantiableMappingHintGroup;
import pamtram.mapping.Mapping;
import pamtram.mapping.MappingHintType;
import pamtram.mapping.ModelConnectionHint;
import pamtram.metamodel.SourceSectionClass;
import pamtram.metamodel.TargetSectionClass;

/**
 * Class for storing HintValues and target section objects generated by applying a Mapping.
 * <p>
 * Objects of this Class can be seen as Instances of a mapping.
 * @author Sascha Steffen
 * @version 0.8
 */
class MappingInstanceStorage {
	/**
	 * The source model Objects, referenced by containment References, that were mapped by this mapping instance.
	 */
	private LinkedHashMap<SourceSectionClass, Set<EObject>> sourceModelObjetsMapped;
	
	/**
	 * Associated Mapping
	 */
	private Mapping mapping;
	
	/**
	 * EObject associated to the root Class of the soureceMMSection of the mapping. 
	 */
	private EObject associatedSourceModelElement;
	
	/**
	 * SourceSectionClass associated to the root Class of the soureceMMSection of the mapping. 
	 */	
	private SourceSectionClass associatedSourceClass;
	

	/**
	 * Generated EObjects sorted bey TargetSectionCLass
	 */
	private LinkedHashMap<InstantiableMappingHintGroup, LinkedHashMap<TargetSectionClass, LinkedList<EObjectTransformationHelper>>> instancesBySection;

	
	/**
	 * HintValues to be used when instantiating the mapping's target section(s)
	 */
	private LinkedHashMap<MappingHintType, LinkedList<Object>> hintValues;

	
	/**
	 * Hint value's to be used when linking the generated sections to the rest of the generated target model
	 */
	private LinkedHashMap<ModelConnectionHint, LinkedList<Object>> modelConnectionHintValues;

	/**
	 * unsynced hints TODO
	 */
	Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMappingSourceElement,String>>> unSyncedComplexAttrMappings;
	Map<SourceSectionClass, LinkedList<Map<ExpressionVariable,String>>> unSyncedCalcMappings;
	Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMatcherSourceElement,String>>> unSyncedComplexAttrMatchers;
	Map<SourceSectionClass, LinkedList<Map<ComplexModelConnectionHintSourceElement,String>>> unSyncedComplexConnectionHints;
	
	
	/**
	 *Constructor 
	 */
	public MappingInstanceStorage() {
		sourceModelObjetsMapped = new LinkedHashMap<SourceSectionClass, Set<EObject>>();
		hintValues = new LinkedHashMap<MappingHintType, LinkedList<Object>>();
		mapping = null;
		associatedSourceModelElement = null;
		associatedSourceClass = null;
		instancesBySection = new LinkedHashMap<InstantiableMappingHintGroup, LinkedHashMap<TargetSectionClass, LinkedList<EObjectTransformationHelper>>>();
		modelConnectionHintValues = new LinkedHashMap<ModelConnectionHint, LinkedList<Object>>();
		unSyncedComplexAttrMappings = new LinkedHashMap<SourceSectionClass, LinkedList<Map<ComplexAttributeMappingSourceElement,String>>>();
		unSyncedCalcMappings = new HashMap<SourceSectionClass, LinkedList<Map<ExpressionVariable,String>>>(); 
		unSyncedComplexAttrMatchers= new HashMap<SourceSectionClass, LinkedList<Map<ComplexAttributeMatcherSourceElement,String>>>();
		unSyncedComplexConnectionHints= new HashMap<SourceSectionClass, LinkedList<Map<ComplexModelConnectionHintSourceElement,String>>>();

	}

	
	public Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMappingSourceElement, String>>> getUnSyncedComplexAttrMappings() {
		return unSyncedComplexAttrMappings;
	}


	public Map<SourceSectionClass, LinkedList<Map<ExpressionVariable, String>>> getUnSyncedCalcMappings() {
		return unSyncedCalcMappings;
	}


	public Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMatcherSourceElement, String>>> getUnSyncedComplexAttrMatchers() {
		return unSyncedComplexAttrMatchers;
	}


	public Map<SourceSectionClass, LinkedList<Map<ComplexModelConnectionHintSourceElement, String>>> getUnSyncedComplexConnectionHints() {
		return unSyncedComplexConnectionHints;
	}


	/**
	 * Add mapped source model Objects and HintValues of another MappingInstanceStorage
	 * @param newRefsAndHints
	 */
	void add(MappingInstanceStorage newRefsAndHints) {
		// combine refs
		this.addSourceModelObjectsMapped(newRefsAndHints.getSourceModelObjectsMapped());

		// combine hints
		this.addHintValues(newRefsAndHints.getHintValues());

		// combine connectionHints
		this.addModelConnectionHintValues(newRefsAndHints
				.getModelConnectionHintValues());
		
		//combine unsynced hints
		this.addUnSyncedHintValues(
				newRefsAndHints.getUnSyncedComplexAttrMappings(),
				newRefsAndHints.getUnSyncedCalcMappings(), 
				newRefsAndHints.getUnSyncedComplexAttrMatchers(), 
				newRefsAndHints.getUnSyncedComplexConnectionHints());

	}

	/**
	 * Add new hint value.
	 * @param hint
	 * @param value
	 */
	void addHintValue(MappingHintType hint, String value) {
		if (!hintValues.containsKey(hint)) {
			hintValues.put(hint, new LinkedList<Object>());
		}
		hintValues.get(hint).add(value);
	}

	/**
	 *Add several new hint values.
	 * @param newHintValues
	 */
	void addHintValues(
			LinkedHashMap<MappingHintType, LinkedList<Object>> newHintValues) {
		for (MappingHintType h : newHintValues.keySet()) {
			if (!hintValues.containsKey(h)) {
				hintValues.put(h, new LinkedList<Object>());
			}
			hintValues.get(h).addAll(newHintValues.get(h));
		}
	}
	//TODO comment
	void addUnSyncedHintValues(	
			Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMappingSourceElement,String>>> unSyncedComplexAttrMappings,
			Map<SourceSectionClass, LinkedList<Map<ExpressionVariable,String>>> unSyncedCalcMappings,
			Map<SourceSectionClass, LinkedList<Map<ComplexAttributeMatcherSourceElement,String>>> unSyncedComplexAttrMatchers,
			Map<SourceSectionClass, LinkedList<Map<ComplexModelConnectionHintSourceElement,String>>> unSyncedComplexConnectionHints){
		
		/*
		 * AttributeMapping
		 */
		for(SourceSectionClass c : unSyncedComplexAttrMappings.keySet()){
			if(!this.unSyncedComplexAttrMappings.containsKey(c)){
				this.unSyncedComplexAttrMappings.put(c, new LinkedList<Map<ComplexAttributeMappingSourceElement,String>>());
			}
			
			this.unSyncedComplexAttrMappings.get(c).addAll(unSyncedComplexAttrMappings.get(c));
		}
		
		/*
		 * CalcMapping
		 */
		for(SourceSectionClass c : unSyncedCalcMappings.keySet()){
			if(!this.unSyncedCalcMappings.containsKey(c)){
				this.unSyncedCalcMappings.put(c, new LinkedList<Map<ExpressionVariable,String>>());
			}
			
			this.unSyncedCalcMappings.get(c).addAll(unSyncedCalcMappings.get(c));
		}	
		
		/*
		 * AttributeMatcher
		 */
		for(SourceSectionClass c : unSyncedComplexAttrMatchers.keySet()){
			if(!this.unSyncedComplexAttrMatchers.containsKey(c)){
				this.unSyncedComplexAttrMatchers.put(c, new LinkedList<Map<ComplexAttributeMatcherSourceElement,String>>());
			}
			
			this.unSyncedComplexAttrMatchers.get(c).addAll(unSyncedComplexAttrMatchers.get(c));
		}		
		
		/*
		 * ModelConnectionHint
		 */
		for(SourceSectionClass c : unSyncedComplexConnectionHints.keySet()){
			if(!this.unSyncedComplexConnectionHints.containsKey(c)){
				this.unSyncedComplexConnectionHints.put(c, new LinkedList<Map<ComplexModelConnectionHintSourceElement,String>>());
			}
			
			this.unSyncedComplexConnectionHints.get(c).addAll(unSyncedComplexConnectionHints.get(c));
		}		
	}

	/**
	 * Register several new target model instances
	 * @param grp
	 * @param section
	 * @param insts
	 */
	void addInstances(InstantiableMappingHintGroup grp,
			TargetSectionClass section, Collection<EObjectTransformationHelper> insts) {
		generateInstancesCollectionsIfNeeded(grp, section);
		instancesBySection.get(grp).get(section).addAll(insts);
	}

	/**
	 * Add new value for a ModelConnectionHint
	 * @param hint
	 * @param value
	 */
	void addModelConnectionHintValue(ModelConnectionHint hint,
			Object value) {
		if (!modelConnectionHintValues.containsKey(hint)) {
			modelConnectionHintValues.put(hint, new LinkedList<Object>());
		}
		modelConnectionHintValues.get(hint).add(value);
	}

	/**
	 * Add  values for several ModelConnectionHints
	 * @param newHintValues
	 */
	void addModelConnectionHintValues(
			LinkedHashMap<ModelConnectionHint, LinkedList<Object>> newHintValues) {
		for (ModelConnectionHint h : newHintValues.keySet()) {
			if (!modelConnectionHintValues.containsKey(h)) {
				modelConnectionHintValues.put(h, new LinkedList<Object>());
			}
			modelConnectionHintValues.get(h).addAll(newHintValues.get(h));
		}
	}

	/**
	 * Register mapped source model objects
	 * @param refs
	 */
	void addSourceModelObjectsMapped(LinkedHashMap<SourceSectionClass, Set<EObject>> refs) {
		for (SourceSectionClass key : refs.keySet()) {
			if (!this.sourceModelObjetsMapped.containsKey(key)) {
				this.sourceModelObjetsMapped.put(key, new LinkedHashSet<EObject>());
			}
			this.sourceModelObjetsMapped.get(key).addAll(refs.get(key));
		}
	}

	/**
	 * Register mapped source model object
	 * @param srcModelElement
	 * @param srcSectionClass
	 */
	void addSourceModelObjectMapped(EObject srcModelElement,
			SourceSectionClass srcSectionClass) {
		if (!sourceModelObjetsMapped.containsKey(srcModelElement)) {
			sourceModelObjetsMapped.put(srcSectionClass, new LinkedHashSet<EObject>());
		}
		sourceModelObjetsMapped.get(srcSectionClass).add(srcModelElement);

	}

	/**
	 * Check source model object registry wether object was mapped already
	 * @param object
	 * @return true - if EObject is registered
	 */
	boolean containsSourceModelObjectMapped(EObject object) {
		return sourceModelObjetsMapped.values().contains(object);
	}

	/**
	 * Generate collections for grp and section in the instancesBySection Map in case they do not exist yet
	 * @param grp
	 * @param section
	 */
	private void generateInstancesCollectionsIfNeeded(InstantiableMappingHintGroup grp,
			TargetSectionClass section) {
		if (!instancesBySection.containsKey(grp)) {
			instancesBySection
					.put(grp,
							new LinkedHashMap<TargetSectionClass, LinkedList<EObjectTransformationHelper>>());
		}

		if (!instancesBySection.get(grp).containsKey(section)) {
			instancesBySection.get(grp).put(section, new LinkedList<EObjectTransformationHelper>());
		}
	}

	/**
	 * @return associated source Model element
	 */
	public EObject getAssociatedSourceModelElement() {
		return associatedSourceModelElement;
	}
	
	/**
	 * @return associated SourceSectionClass
	 */
	public SourceSectionClass getAssociatedSourceClass() {
		return associatedSourceClass;
	}

	/**
	 * Getter for the hintValues Map
	 * @return hint values
	 */
	public LinkedHashMap<MappingHintType, LinkedList<Object>> getHintValues() {
		return hintValues;
	}

	
	/**
	 * Get generated target section instances associated with the MappingHintGroup
	 * @param group
	 * @return generated target section instances associated with the MappingHintGroup
	 */
	LinkedHashMap<TargetSectionClass, LinkedList<EObjectTransformationHelper>> getInstancesBySection(InstantiableMappingHintGroup group) {
			return instancesBySection.get(group);
	}
	
	/**
	 *  generated target section instances associated with the MappingHintGroup and the specific section
	 * @param group
	 * @param section
	 * @return
	 */
	LinkedList<EObjectTransformationHelper> getInstances(InstantiableMappingHintGroup group, TargetSectionClass section) {
		if(instancesBySection.containsKey(group)){
				return instancesBySection.get(group).get(section);

		} else return null;
	}

	/**
	 * @return associated Mapping
	 */
	public Mapping getMapping() {
		return mapping;
	}

	/**
	 * @return hint values for the ModelConnectionHints, created during the mapping of the source section
	 */
	public final LinkedHashMap<ModelConnectionHint, LinkedList<Object>> getModelConnectionHintValues() {
		return modelConnectionHintValues;
	}

	
	/**
	 * @param hint
	 * @return ModelConnectionHint values for the specified target section
	 */
	LinkedList<Object> getModelConnectionHintValues(
			ModelConnectionHint hint) {

		if (modelConnectionHintValues.containsKey(hint)) {
			return modelConnectionHintValues.get(hint);
		} else {
			return new LinkedList<Object>();
		}
	}

	/**
	 * @return map of the source model Objects mapped
	 */
	public final LinkedHashMap<SourceSectionClass, Set<EObject>> getSourceModelObjectsMapped() {
		return sourceModelObjetsMapped;
	}

	/**
	 * @param associatedSourceClass
	 * @param associatedSourceModelElement
	 */
	public void setAssociatedSourceElement(
			SourceSectionClass associatedSourceClass,
			EObject associatedSourceModelElement) {
		this.associatedSourceModelElement = associatedSourceModelElement;
		this.associatedSourceClass=associatedSourceClass;
	}

	/**
	 * Set the values for a mapping hint
	 * @param hint
	 * @param newHintValues
	 */
	void setHintValueList(MappingHintType hint,
			LinkedList<Object> newHintValues) {
		hintValues.put(hint, newHintValues);

	}
	
	/**
	 * Set the values for a model connection hint
	 * @param hint
	 * @param newHintValues
	 */
	void setConnectionHintValueList(ModelConnectionHint hint,
			LinkedList<Object> newHintValues) {
		modelConnectionHintValues.put(hint, newHintValues);

	}

	/**
	 * Set the associated mapping
	 * @param mapping
	 */
	public void setMapping(Mapping mapping) {
		this.mapping = mapping;
	}

	/**
	 * Set the map of source model objects mapped
	 * @param refs
	 */
	public void setSourceModelObjectsMapped(LinkedHashMap<SourceSectionClass, Set<EObject>> refs) {
		this.sourceModelObjetsMapped = refs;
	}

}
